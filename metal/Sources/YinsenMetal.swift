/*
 * YINSEN Metal - Swift API
 *
 * High-level Swift bindings for Yinsen Metal kernels.
 * Provides safe, ergonomic access to ternary compute operations.
 *
 * All kernels use canonical trit encoding (see trit_encoding.h):
 *   00 = 0, 01 = +1, 10 = -1, 11 = reserved (decoded as 0)
 */

import Metal
import Foundation

// =============================================================================
// YINSEN METAL CONTEXT
// =============================================================================

public class YinsenMetal {
    public let device: MTLDevice
    public let commandQueue: MTLCommandQueue
    public let library: MTLLibrary
    
    // Cached pipeline states
    private var pipelines: [String: MTLComputePipelineState] = [:]
    
    public init() throws {
        guard let device = MTLCreateSystemDefaultDevice() else {
            throw YinsenMetalError.noDevice
        }
        self.device = device
        
        guard let queue = device.makeCommandQueue() else {
            throw YinsenMetalError.noCommandQueue
        }
        self.commandQueue = queue
        
        // Load kernel source from bundle resources
        // Package.swift copies .metal files as resources; we concatenate and compile them.
        let source = try YinsenMetal.loadKernelSourceFromBundle()
        self.library = try device.makeLibrary(source: source, options: nil)
    }
    
    /// Load all .metal kernel sources from the Swift Package bundle resources.
    /// Falls back to file-system relative path for development builds.
    private static func loadKernelSourceFromBundle() throws -> String {
        let metalFiles = [
            "ternary_core.metal",
            "ternary_8x8.metal",
            "ternary_matvec_tiled.metal",
            "activations.metal",
            "layernorm.metal"
        ]
        
        var source = ""
        
        // Try bundle resources first (works when built as Swift Package)
        if let bundle = Bundle(identifier: "YinsenMetal"),
           let resourcePath = bundle.resourcePath {
            for file in metalFiles {
                let path = (resourcePath as NSString).appendingPathComponent(file)
                if FileManager.default.fileExists(atPath: path) {
                    source += try String(contentsOfFile: path)
                    source += "\n"
                }
            }
            if !source.isEmpty { return source }
        }
        
        // Try Bundle.module (SPM-generated resource accessor)
        // Bundle.module is auto-generated by SPM when resources are declared.
        // We access it dynamically to avoid compile errors in non-SPM contexts.
        let moduleBundle = Bundle(for: YinsenMetal.self)
        for file in metalFiles {
            let name = (file as NSString).deletingPathExtension
            if let url = moduleBundle.url(forResource: name, withExtension: "metal") {
                source += try String(contentsOf: url)
                source += "\n"
            }
        }
        if !source.isEmpty { return source }
        
        // Fallback: load from relative path (development/testing)
        let basePath = URL(fileURLWithPath: #file)
            .deletingLastPathComponent()
            .deletingLastPathComponent()
            .appendingPathComponent("kernels")
        
        for file in metalFiles {
            let path = basePath.appendingPathComponent(file)
            if FileManager.default.fileExists(atPath: path.path) {
                source += try String(contentsOf: path)
                source += "\n"
            }
        }
        
        if source.isEmpty {
            throw YinsenMetalError.kernelNotFound("No .metal files found in bundle or filesystem")
        }
        
        return source
    }
    
    // =========================================================================
    // PIPELINE MANAGEMENT
    // =========================================================================
    
    public func getPipeline(name: String) throws -> MTLComputePipelineState {
        if let cached = pipelines[name] {
            return cached
        }
        
        guard let function = library.makeFunction(name: name) else {
            throw YinsenMetalError.kernelNotFound(name)
        }
        
        let pipeline = try device.makeComputePipelineState(function: function)
        pipelines[name] = pipeline
        return pipeline
    }
    
    // =========================================================================
    // HIGH-LEVEL OPERATIONS
    // =========================================================================
    
    /// Ternary matrix-vector multiply: y = W @ x
    /// Uses the threadgroup-cooperative tiled kernel for large matrices.
    public func ternaryMatvec(
        weights: MTLBuffer,  // Packed ternary [M x ceil(N/4)]
        input: MTLBuffer,    // Float [N]
        output: MTLBuffer,   // Float [M]
        M: Int,
        N: Int
    ) throws {
        let pipeline = try getPipeline(name: "ternary_matvec_tiled")
        
        guard let commandBuffer = commandQueue.makeCommandBuffer(),
              let encoder = commandBuffer.makeComputeCommandEncoder() else {
            throw YinsenMetalError.commandBufferFailed
        }
        
        var m = UInt32(M)
        var n = UInt32(N)
        
        encoder.setComputePipelineState(pipeline)
        encoder.setBuffer(weights, offset: 0, index: 0)
        encoder.setBuffer(input, offset: 0, index: 1)
        encoder.setBuffer(output, offset: 0, index: 2)
        encoder.setBytes(&m, length: MemoryLayout<UInt32>.size, index: 3)
        encoder.setBytes(&n, length: MemoryLayout<UInt32>.size, index: 4)
        
        // One threadgroup per row, up to 256 threads per threadgroup
        let threadsPerGroup = min(256, pipeline.maxTotalThreadsPerThreadgroup)
        let threadgroupSize = MTLSize(width: threadsPerGroup, height: 1, depth: 1)
        let gridSize = MTLSize(width: M, height: 1, depth: 1)
        
        // Shared memory: max(N, num_simdgroups) floats (reused for reduction)
        let numSimdgroups = (threadsPerGroup + 31) / 32
        let sharedMemSize = max(N, numSimdgroups) * MemoryLayout<Float>.size
        encoder.setThreadgroupMemoryLength(sharedMemSize, index: 0)
        
        encoder.dispatchThreadgroups(gridSize, threadsPerThreadgroup: threadgroupSize)
        
        encoder.endEncoding()
        commandBuffer.commit()
        commandBuffer.waitUntilCompleted()
    }
    
    /// Ternary matrix-vector multiply with bias: y = W @ x + b
    public func ternaryMatvecBias(
        weights: MTLBuffer,
        input: MTLBuffer,
        bias: MTLBuffer,
        output: MTLBuffer,
        M: Int,
        N: Int
    ) throws {
        let pipeline = try getPipeline(name: "ternary_matvec_tiled_bias")
        
        guard let commandBuffer = commandQueue.makeCommandBuffer(),
              let encoder = commandBuffer.makeComputeCommandEncoder() else {
            throw YinsenMetalError.commandBufferFailed
        }
        
        var m = UInt32(M)
        var n = UInt32(N)
        
        encoder.setComputePipelineState(pipeline)
        encoder.setBuffer(weights, offset: 0, index: 0)
        encoder.setBuffer(input, offset: 0, index: 1)
        encoder.setBuffer(bias, offset: 0, index: 2)
        encoder.setBuffer(output, offset: 0, index: 3)
        encoder.setBytes(&m, length: MemoryLayout<UInt32>.size, index: 4)
        encoder.setBytes(&n, length: MemoryLayout<UInt32>.size, index: 5)
        
        let threadsPerGroup = min(256, pipeline.maxTotalThreadsPerThreadgroup)
        let threadgroupSize = MTLSize(width: threadsPerGroup, height: 1, depth: 1)
        let gridSize = MTLSize(width: M, height: 1, depth: 1)
        
        let numSimdgroups2 = (threadsPerGroup + 31) / 32
        let sharedMemSize2 = max(N, numSimdgroups2) * MemoryLayout<Float>.size
        encoder.setThreadgroupMemoryLength(sharedMemSize2, index: 0)
        
        encoder.dispatchThreadgroups(gridSize, threadsPerThreadgroup: threadgroupSize)
        
        encoder.endEncoding()
        commandBuffer.commit()
        commandBuffer.waitUntilCompleted()
    }
    
    /// GELU activation
    public func gelu(input: MTLBuffer, output: MTLBuffer, n: Int) throws {
        let pipeline = try getPipeline(name: "gelu")
        
        guard let commandBuffer = commandQueue.makeCommandBuffer(),
              let encoder = commandBuffer.makeComputeCommandEncoder() else {
            throw YinsenMetalError.commandBufferFailed
        }
        
        var count = UInt32(n)
        
        encoder.setComputePipelineState(pipeline)
        encoder.setBuffer(input, offset: 0, index: 0)
        encoder.setBuffer(output, offset: 0, index: 1)
        encoder.setBytes(&count, length: MemoryLayout<UInt32>.size, index: 2)
        
        let gridSize = MTLSize(width: n, height: 1, depth: 1)
        let threadgroupSize = MTLSize(width: min(n, pipeline.maxTotalThreadsPerThreadgroup), height: 1, depth: 1)
        encoder.dispatchThreads(gridSize, threadsPerThreadgroup: threadgroupSize)
        
        encoder.endEncoding()
        commandBuffer.commit()
        commandBuffer.waitUntilCompleted()
    }
    
    // =========================================================================
    // BUFFER HELPERS
    // =========================================================================
    
    public func makeBuffer<T>(from array: [T]) -> MTLBuffer? {
        return device.makeBuffer(
            bytes: array,
            length: array.count * MemoryLayout<T>.size,
            options: .storageModeShared
        )
    }
    
    public func makeBuffer(length: Int) -> MTLBuffer? {
        return device.makeBuffer(length: length, options: .storageModeShared)
    }
}

// =============================================================================
// ERROR TYPES
// =============================================================================

public enum YinsenMetalError: Error {
    case noDevice
    case noCommandQueue
    case kernelNotFound(String)
    case commandBufferFailed
    case bufferCreationFailed
}
